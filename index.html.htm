<script>
/* =========================================
   ЧАСТЬ 2: ПОЛУМЕСЯЦ + ЗВЕЗДА (DELUXE)
========================================= */

const container = document.getElementById('canvas-container');
container.innerHTML = '';

const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x03040a, 0.020);

const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1400);
camera.position.set(0, 2.0, 56);

const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
renderer.outputEncoding = THREE.sRGBEncoding;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.15;
renderer.physicallyCorrectLights = true;
container.appendChild(renderer.domElement);

/* --- Свет (чтобы “золото” читалось объёмно) --- */
scene.add(new THREE.AmbientLight(0xffffff, 0.16));

const key = new THREE.PointLight(0xffd7a3, 120, 250);     // тёплый
key.position.set(26, 30, 44);
scene.add(key);

const rim = new THREE.PointLight(0x5bffe7, 70, 250);      // холодный контровый
rim.position.set(-34, -10, 30);
scene.add(rim);

const topFill = new THREE.DirectionalLight(0xffffff, 0.25);
topFill.position.set(-8, 20, 15);
scene.add(topFill);

/* --- Градиентная “подложка” (очень мягко) --- */
{
  const bgGeo = new THREE.SphereGeometry(420, 32, 32);
  const bgMat = new THREE.MeshBasicMaterial({ color: 0x050814, side: THREE.BackSide });
  const bg = new THREE.Mesh(bgGeo, bgMat);
  scene.add(bg);
}

/* --- Группа для параллакса --- */
const symbolGroup = new THREE.Group();
scene.add(symbolGroup);

/* ---------- Вспомогательное: спрайтовый ореол ---------- */
function makeHaloSprite(color1, color2, size, opacity) {
  const c = document.createElement('canvas');
  c.width = 256; c.height = 256;
  const ctx = c.getContext('2d');

  const grd = ctx.createRadialGradient(128, 128, 0, 128, 128, 128);
  grd.addColorStop(0.00, color1);
  grd.addColorStop(0.35, color2);
  grd.addColorStop(1.00, 'rgba(0,0,0,0)');

  ctx.fillStyle = grd;
  ctx.fillRect(0, 0, 256, 256);

  const tex = new THREE.CanvasTexture(c);
  tex.needsUpdate = true;

  const mat = new THREE.SpriteMaterial({
    map: tex,
    transparent: true,
    opacity,
    depthWrite: false,
    blending: THREE.AdditiveBlending
  });

  const spr = new THREE.Sprite(mat);
  spr.scale.set(size, size, 1);
  return spr;
}

/* ---------- Полумесяц: экструдированная форма с вырезом ---------- */
function createCrescent() {
  const outerR = 15.0;
  const innerR = 12.0;
  const shiftX = 5.6;          // сдвиг выреза -> “правильный” полумесяц

  const shape = new THREE.Shape();
  shape.absarc(0, 0, outerR, 0, Math.PI * 2, false);

  const hole = new THREE.Path();
  hole.absarc(shiftX, 0, innerR, 0, Math.PI * 2, true);
  shape.holes.push(hole);

  const geo = new THREE.ExtrudeGeometry(shape, {
    depth: 2.8,
    bevelEnabled: true,
    bevelThickness: 1.0,
    bevelSize: 0.85,
    bevelSegments: 10,
    curveSegments: 96
  });
  geo.center();

  // База: золото
  const gold = new THREE.MeshPhysicalMaterial({
    color: 0xffd06a,
    metalness: 1.0,
    roughness: 0.18,
    clearcoat: 1.0,
    clearcoatRoughness: 0.10,
    reflectivity: 0.9,
    emissive: 0x1c0f00,
    emissiveIntensity: 0.22
  });

  // Тонкий “эмалевый” слой (чуть холоднее) — для богатого оттенка
  const enamel = new THREE.MeshPhysicalMaterial({
    color: 0x0b3a2d,
    metalness: 0.35,
    roughness: 0.22,
    clearcoat: 1.0,
    clearcoatRoughness: 0.08,
    transparent: true,
    opacity: 0.14,
    depthWrite: false
  });

  const meshGold = new THREE.Mesh(geo, gold);
  meshGold.rotation.set(-0.18, 0.30, 0.58);
  meshGold.position.set(0, 0, -8);

  const meshEnamel = new THREE.Mesh(geo.clone(), enamel);
  meshEnamel.rotation.copy(meshGold.rotation);
  meshEnamel.position.copy(meshGold.position);
  meshEnamel.scale.setScalar(1.001);

  // Свечение по контуру: увеличенная копия + additive
  const edgeGlow = new THREE.Mesh(
    geo.clone(),
    new THREE.MeshBasicMaterial({
      color: 0x00ffbf,
      transparent: true,
      opacity: 0.10,
      blending: THREE.AdditiveBlending,
      depthWrite: false
    })
  );
  edgeGlow.rotation.copy(meshGold.rotation);
  edgeGlow.position.copy(meshGold.position);
  edgeGlow.scale.setScalar(1.035);

  // Большой ореол-спрайт позади
  const halo = makeHaloSprite('rgba(0,255,190,0.35)', 'rgba(255,208,106,0.10)', 120, 0.55);
  halo.position.set(0, 0, -18);

  const g = new THREE.Group();
  g.add(halo);
  g.add(edgeGlow);
  g.add(meshGold);
  g.add(meshEnamel);

  return { g, edgeGlow, halo };
}

/* ---------- Звезда (5-конечная, экструдированная) ---------- */
function createStar() {
  const starShape = new THREE.Shape();
  const spikes = 5;
  const outer = 3.1;
  const inner = 1.35;

  let rot = Math.PI / 2 * 3;
  const step = Math.PI / spikes;

  starShape.moveTo(0, -outer);
  for (let i = 0; i < spikes; i++) {
    starShape.lineTo(Math.cos(rot) * outer, Math.sin(rot) * outer);
    rot += step;
    starShape.lineTo(Math.cos(rot) * inner, Math.sin(rot) * inner);
    rot += step;
  }
  starShape.closePath();

  const geo = new THREE.ExtrudeGeometry(starShape, {
    depth: 1.6,
    bevelEnabled: true,
    bevelThickness: 0.55,
    bevelSize: 0.35,
    bevelSegments: 8,
    curveSegments: 48
  });
  geo.center();

  const mat = new THREE.MeshPhysicalMaterial({
    color: 0xfff0b0,
    metalness: 1.0,
    roughness: 0.22,
    clearcoat: 1.0,
    clearcoatRoughness: 0.12,
    emissive: 0x2a2100,
    emissiveIntensity: 0.20
  });

  const mesh = new THREE.Mesh(geo, mat);

  // Позиция “классической” композиции: внутри полумесяца
  mesh.position.set(9.2, 5.3, -5.6);
  mesh.rotation.set(0.25, -0.25, 0.15);

  // Ореол + мягкая искра
  const halo = makeHaloSprite('rgba(255,240,176,0.55)', 'rgba(255,208,106,0.12)', 44, 0.70);
  halo.position.copy(mesh.position);
  halo.position.z -= 6.0;

  const glow = new THREE.Mesh(
    geo.clone(),
    new THREE.MeshBasicMaterial({
      color: 0xffd06a,
      transparent: true,
      opacity: 0.10,
      blending: THREE.AdditiveBlending,
      depthWrite: false
    })
  );
  glow.position.copy(mesh.position);
  glow.rotation.copy(mesh.rotation);
  glow.scale.setScalar(1.08);

  const g = new THREE.Group();
  g.add(halo);
  g.add(glow);
  g.add(mesh);
  return { g, mesh, halo };
}

/* ---------- “Пыль/искры” вокруг символа ---------- */
function createSparkles(count = 900) {
  const geo = new THREE.BufferGeometry();
  const pos = new Float32Array(count * 3);
  const col = new Float32Array(count * 3);

  for (let i = 0; i < count; i++) {
    const i3 = i * 3;

    // Сконцентрируем вокруг центра, чтобы было “магически”
    const r = Math.pow(Math.random(), 0.55) * 55;
    const a = Math.random() * Math.PI * 2;
    const y = (Math.random() - 0.5) * 40;

    pos[i3 + 0] = Math.cos(a) * r;
    pos[i3 + 1] = y;
    pos[i3 + 2] = Math.sin(a) * r - 30;

    const t = Math.random();
    if (t > 0.75) { col[i3]=0.35; col[i3+1]=1.00; col[i3+2]=0.85; }
    else if (t > 0.50) { col[i3]=1.00; col[i3+1]=0.86; col[i3+2]=0.45; }
    else { col[i3]=1.00; col[i3+1]=1.00; col[i3+2]=1.00; }
  }

  geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
  geo.setAttribute('color', new THREE.BufferAttribute(col, 3));

  const mat = new THREE.PointsMaterial({
    size: 0.55,
    vertexColors: true,
    transparent: true,
    opacity: 0.75,
    blending: THREE.AdditiveBlending,
    depthWrite: false
  });

  return new THREE.Points(geo, mat);
}

/* ---------- Дальний starfield (фон) ---------- */
function createStarField(count = 1600) {
  const geo = new THREE.BufferGeometry();
  const pos = new Float32Array(count * 3);
  const col = new Float32Array(count * 3);

  for (let i = 0; i < count; i++) {
    const i3 = i * 3;
    pos[i3 + 0] = (Math.random() - 0.5) * 260;
    pos[i3 + 1] = (Math.random() - 0.5) * 260;
    pos[i3 + 2] = (Math.random() - 0.5) * 160 - 80;

    const t = Math.random();
    if (t > 0.86) { col[i3]=0.30; col[i3+1]=0.95; col[i3+2]=0.85; }
    else if (t > 0.62) { col[i3]=1.00; col[i3+1]=0.86; col[i3+2]=0.50; }
    else { col[i3]=1.00; col[i3+1]=1.00; col[i3+2]=1.00; }
  }

  geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
  geo.setAttribute('color', new THREE.BufferAttribute(col, 3));

  const mat = new THREE.PointsMaterial({
    size: 0.45,
    vertexColors: true,
    transparent: true,
    opacity: 0.70,
    blending: THREE.AdditiveBlending,
    depthWrite: false
  });

  return new THREE.Points(geo, mat);
}

/* --- Создаём композицию --- */
const crescent = createCrescent();
symbolGroup.add(crescent.g);

const starObj = createStar();
symbolGroup.add(starObj.g);

const sparkles = createSparkles(900);
scene.add(sparkles);

const farStars = createStarField(1600);
scene.add(farStars);

/* --- Параллакс --- */
let mx = 0, my = 0;
document.addEventListener('mousemove', (e) => {
  mx = (e.clientX - window.innerWidth / 2) / (window.innerWidth / 2);
  my = (e.clientY - window.innerHeight / 2) / (window.innerHeight / 2);
});

/* --- Анимация --- */
const clock = new THREE.Clock();

function animate() {
  requestAnimationFrame(animate);
  const t = clock.getElapsedTime();

  // Базовое “плавание”
  symbolGroup.rotation.y = 0.25 + Math.sin(t * 0.18) * 0.06;
  symbolGroup.rotation.x = -0.05 + Math.sin(t * 0.22) * 0.05;

  // Параллакс (мягко)
  symbolGroup.rotation.y += (mx * 0.18 - symbolGroup.rotation.y) * 0.03;
  symbolGroup.rotation.x += (-my * 0.12 - symbolGroup.rotation.x) * 0.03;

  // Чуть-чуть вращаем символ целиком
  symbolGroup.rotation.z = Math.sin(t * 0.10) * 0.03;

  // Мерцание свечения (аккуратно, чтобы не “кислотно”)
  crescent.edgeGlow.material.opacity = 0.085 + Math.sin(t * 1.4) * 0.018;
  crescent.halo.material.opacity = 0.50 + Math.sin(t * 0.8) * 0.08;
  starObj.halo.material.opacity = 0.62 + Math.sin(t * 1.1) * 0.10;

  // Звезда слегка “играет”
  starObj.mesh.rotation.z += 0.0032;

  // Движение частиц
  farStars.rotation.y = t * 0.02;
  farStars.rotation.x = t * 0.01;
  sparkles.rotation.y = -t * 0.035;

  renderer.render(scene, camera);
}
animate();

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
